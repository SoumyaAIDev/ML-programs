pragma solidity 0.5.0; contract Context { constructor () internal { } function _msgSender() internal view returns (address payable) { return msg.sender; } function _msgData() internal view returns (bytes memory) { this; return msg.data; } } interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address recipient, uint256 amount) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 amount) external returns (bool); function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, "SafeMath: addition overflow"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { return sub(a, b, "SafeMath: subtraction overflow"); } function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b, "SafeMath: multiplication overflow"); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return div(a, b, "SafeMath: division by zero"); } function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b > 0, errorMessage); uint256 c = a / b; return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { return mod(a, b, "SafeMath: modulo by zero"); } function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); return a % b; } } contract ERC20 is Context, IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowances; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; } function balanceOf(address account) public view returns (uint256) { return _balances[account]; } function transfer(address recipient, uint256 amount) public returns (bool) { _transfer(_msgSender(), recipient, amount); return true; } function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; } function approve(address spender, uint256 amount) public returns (bool) { _approve(_msgSender(), spender, amount); return true; } function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) { _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true; } function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); return true; } function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero")); return true; } function _transfer(address sender, address recipient, uint256 amount) internal { require(sender != address(0), "ERC20: transfer from the zero address"); require(recipient != address(0), "ERC20: transfer to the zero address"); _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance"); _balances[recipient] = _balances[recipient].add(amount); emit Transfer(sender, recipient, amount); } function _mint(address account, uint256 amount) internal { require(account != address(0), "ERC20: mint to the zero address"); _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount); } function _burn(address account, uint256 amount) internal { require(account != address(0), "ERC20: burn from the zero address"); _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance"); _totalSupply = _totalSupply.sub(amount); emit Transfer(account, address(0), amount); } function _approve(address owner, address spender, uint256 amount) internal { require(owner != address(0), "ERC20: approve from the zero address"); require(spender != address(0), "ERC20: approve to the zero address"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); } function _burnFrom(address account, uint256 amount) internal { _burn(account, amount); _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance")); } } contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; constructor (string memory name, string memory symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; } function name() public view returns (string memory) { return _name; } function symbol() public view returns (string memory) { return _symbol; } function decimals() public view returns (uint8) { return _decimals; } } contract YFATM is ERC20, ERC20Detailed { address owner; using SafeMath for uint256; ERC20 public token; constructor () public ERC20Detailed("YFATOM", "YFATM", 18) { _mint(msg.sender, 15000 * (10 ** uint256(decimals()))); owner=msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); owner = newOwner; } }
gpt-4
Make a smart contract to implement a timelock mechanism for executing transactions. The purpose of this contract is to allow for delayed execution of transactions, ensuring that they can only be executed after a certain time period has passed. The contract includes functions for queuing, canceling, and executing transactions, as well as events to track these actions. The delay period is configurable within certain limits.
pragma solidity 0.5.17; contract Timelock { using SafeMath for uint256; /// @notice An event emitted when the timelock admin changes event NewAdmin(address indexed newAdmin); /// @notice An event emitted when a new admin is staged in the timelock event NewPendingAdmin(address indexed newPendingAdmin); event NewDelay(uint indexed newDelay); /// @notice An event emitted when a queued transaction is cancelled event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta); /// @notice An event emitted when a queued transaction is executed event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta); /// @notice An event emitted when a new transaction is queued event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta); /// @notice the length of time after the delay has passed that a transaction can be executed uint256 public constant GRACE_PERIOD = 14 days; /// @notice the minimum length of the timelock delay uint256 public constant MINIMUM_DELAY = 12 hours + 2*60*15; // have to be present for 2 rebases /// @notice the maximum length of the timelock delay uint256 public constant MAXIMUM_DELAY = 30 days; address public admin; address public pendingAdmin; uint256 public delay; bool public admin_initialized; mapping (bytes32 => bool) public queuedTransactions; constructor() public { /* require(delay_ >= MINIMUM_DELAY, "Timelock::constructor: Delay must exceed minimum delay."); require(delay_ <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay."); */ admin = msg.sender; delay = MINIMUM_DELAY; admin_initialized = false; } function() external payable { } /** @notice sets the delay @param delay_ the new delay */ function setDelay(uint256 delay_) public { require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock."); require(delay_ >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay."); require(delay_ <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay."); delay = delay_; emit NewDelay(delay); } /// @notice sets the new admin address function acceptAdmin() public { require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin."); admin = msg.sender; pendingAdmin = address(0); emit NewAdmin(admin); } /** @notice queues a new pendingAdmin @param pendingAdmin_ the new pendingAdmin address */ function setPendingAdmin(address pendingAdmin_) public { // allows one time setting of admin for deployment purposes if (admin_initialized) { require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock."); } else { admin_initialized = true; } pendingAdmin = pendingAdmin_; emit NewPendingAdmin(pendingAdmin); } function queueTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public returns (bytes32) { require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin."); require(eta >= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay."); bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); queuedTransactions[txHash] = true; emit QueueTransaction(txHash, target, value, signature, data, eta); return txHash; } function cancelTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public { require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin."); bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); queuedTransactions[txHash] = false; emit CancelTransaction(txHash, target, value, signature, data, eta); } function executeTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public payable returns (bytes memory) { require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin."); // timelock not enforced prior to updating the admin. This should occur on // deployment. bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); if (admin_initialized) { require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn't been queued."); require(getBlockTimestamp() >= eta, "Timelock::executeTransaction: Transaction hasn't surpassed time lock."); require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), "Timelock::executeTransaction: Transaction is stale."); queuedTransactions[txHash] = false; } bytes memory callData; if (bytes(signature).length == 0) { callData = data; } else { callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); } // solium-disable-next-line security/no-call-value (bool success, bytes memory returnData) = target.call.value(value)(callData); require(success, "Timelock::executeTransaction: Transaction execution reverted."); emit ExecuteTransaction(txHash, target, value, signature, data, eta); return returnData; } function getBlockTimestamp() internal view returns (uint256) { // solium-disable-next-line security/no-block-members return block.timestamp; } } library SafeMath { /** * @dev Returns the addition of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `+` operator. * * Requirements: * * - Addition cannot overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, "SafeMath: addition overflow"); return c; } /** * @dev Returns the subtraction of two unsigned integers, reverting on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * * - Subtraction cannot overflow. */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { return sub(a, b, "SafeMath: subtraction overflow"); } /** * @dev Returns the subtraction of two unsigned integers, reverting with custom message on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * * - Subtraction cannot overflow. */ function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; } /** * @dev Returns the multiplication of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `*` operator. * * Requirements: * * - Multiplication cannot overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b, "SafeMath: multiplication overflow"); return c; } /** * @dev Returns the integer division of two unsigned integers. Reverts on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * * - The divisor cannot be zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { return div(a, b, "SafeMath: division by zero"); } /** * @dev Returns the integer division of two unsigned integers. Reverts with custom message on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * * - The divisor cannot be zero. */ function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b > 0, errorMessage); uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * * - The divisor cannot be zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { return mod(a, b, "SafeMath: modulo by zero"); } /** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts with custom message when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * * - The divisor cannot be zero. */ function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); return a % b; } }
gpt-4
Make a smart contract to propose and vote on various changes to the SeedDAO system. The contract allows for proposals related to funding, melody addition/removal, stake upgrade, and DAO upgrade. Stakers can vote on proposals, and if a proposal receives enough votes, it can be completed. The contract ensures that only valid and meaningful proposals are acted upon.
pragma solidity 0.7.0; interface IOwnershipTransferrable { function transferOwnership(address owner) external; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); } abstract contract Ownable is IOwnershipTransferrable { address private _owner; constructor(address owner) { _owner = owner; emit OwnershipTransferred(address(0), _owner); } function owner() public view returns (address) { return _owner; } modifier onlyOwner() { require(_owner == msg.sender, "Ownable: caller is not the owner"); _; } function transferOwnership(address newOwner) override external onlyOwner { require(newOwner != address(0), "Ownable: new owner is the zero address"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } contract Seed is Ownable { using SafeMath for uint256; uint256 constant UINT256_MAX = ~uint256(0); string private _name; string private _symbol; uint8 private _decimals; uint256 private _totalSupply; mapping(address => uint256) private _balances; mapping(address => mapping(address => uint256)) private _allowances; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() Ownable(msg.sender) { _totalSupply = 1000000 * 1e18; _name = "Seed"; _symbol = "SEED"; _decimals = 18; _balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); } function name() external view returns (string memory) { return _name; } function symbol() external view returns (string memory) { return _symbol; } function decimals() external view returns (uint8) { return _decimals; } function totalSupply() external view returns (uint256) { return _totalSupply; } function balanceOf(address account) external view returns (uint256) { return _balances[account]; } function allowance(address owner, address spender) external view returns (uint256) { return _allowances[owner][spender]; } function transfer(address recipient, uint256 amount) external returns (bool) { _transfer(msg.sender, recipient, amount); return true; } function approve(address spender, uint256 amount) external returns (bool) { _approve(msg.sender, spender, amount); return true; } function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) { _transfer(sender, recipient, amount); if (_allowances[msg.sender][sender] != UINT256_MAX) { _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount)); } return true; } function _transfer(address sender, address recipient, uint256 amount) internal { require(sender != address(0)); require(recipient != address(0)); _balances[sender] = _balances[sender].sub(amount); _balances[recipient] = _balances[recipient].add(amount); emit Transfer(sender, recipient, amount); } function mint(address account, uint256 amount) external onlyOwner { _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount); } function increaseAllowance(address spender, uint256 addedValue) external returns (bool) { _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)); return true; } function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) { _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue)); return true; } function _approve(address owner, address spender, uint256 amount) internal { require(owner != address(0)); require(spender != address(0)); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); } function burn(uint256 amount) external returns (bool) { _balances[msg.sender] = _balances[msg.sender].sub(amount); _totalSupply = _totalSupply.sub(amount); emit Transfer(msg.sender, address(0), amount); return true; } } abstract contract ReentrancyGuard { bool private _entered; modifier noReentrancy() { require(!_entered); _entered = true; _; _entered = false; } } interface ISeedStake is IOwnershipTransferrable { event StakeIncreased(address indexed staker, uint256 amount); event StakeDecreased(address indexed staker, uint256 amount); event Rewards(address indexed staker, uint256 mintage, uint256 developerFund); event MelodyAdded(address indexed melody); event MelodyRemoved(address indexed melody); function seed() external returns (address); function totalStaked() external returns (uint256); function staked(address staker) external returns (uint256); function lastClaim(address staker) external returns (uint256); function addMelody(address melody) external; function removeMelody(address melody) external; function upgrade(address owned, address upgraded) external; } contract SeedDAO is ReentrancyGuard { using SafeMath for uint256; // Proposal fee of 10 SEED. Used to prevent spam uint256 constant PROPOSAL_FEE = 10 * 1e18; event NewProposal(uint64 indexed proposal); event FundProposed(uint64 indexed proposal, address indexed destination, uint256 amount); event MelodyAdditionProposed(uint64 indexed proposal, address melody); event MelodyRemovalProposed(uint64 indexed proposal, address melody); event StakeUpgradeProposed(uint64 indexed proposal, address newStake); event DAOUpgradeProposed(uint64 indexed proposal, address newDAO); event ProposalVoteAdded(uint64 indexed proposal, address indexed staker); event ProposalVoteRemoved(uint64 indexed proposal, address indexed staker); event ProposalPassed(uint64 indexed proposal); event ProposalRemoved(uint64 indexed proposal); enum ProposalType { Null, Fund, MelodyAddition, MelodyRemoval, StakeUpgrade, DAOUpgrade } struct ProposalMetadata { ProposalType pType; // Allows the creator to withdraw the proposal address creator; // Used to mark proposals older than 30 days as invalid uint256 submitted; // Stakers who voted yes mapping(address => bool) stakers; // Whether or not the proposal is completed // Stops it from being acted on multiple times bool completed; } // The info string is intended for an URL to describe the proposal struct FundProposal { address destination; uint256 amount; string info; } struct MelodyAdditionProposal { address melody; string info; } struct MelodyRemovalProposal { address melody; string info; } struct StakeUpgradeProposal { address newStake; // List of addresses owned by the Stake contract address[] owned; string info; } struct DAOUpgradeProposal { address newDAO; string info; } mapping(uint64 => ProposalMetadata) public proposals; mapping(uint64 => mapping(address => bool)) public used; mapping(uint64 => FundProposal) public _fundProposals; mapping(uint64 => MelodyAdditionProposal) public _melodyAdditionProposals; mapping(uint64 => MelodyRemovalProposal) public _melodyRemovalProposals; mapping(uint64 => StakeUpgradeProposal) public _stakeUpgradeProposals; mapping(uint64 => DAOUpgradeProposal) public _daoUpgradeProposals; // Address of the DAO we upgraded to address _upgrade; // ID to use for the next proposal uint64 _nextProposalID; ISeedStake private _stake; Seed private _SEED; // Check the proposal is valid modifier pendingProposal(uint64 proposal) { require(proposals[proposal].pType != ProposalType.Null); require(!proposals[proposal].completed); // Don't allow old proposals to suddenly be claimed require(proposals[proposal].submitted + 30 days > block.timestamp); _; } // Check this contract hasn't been replaced modifier active() { require(_upgrade == address(0)); _; } constructor(address stake) { _stake = ISeedStake(stake); _SEED = Seed(_stake.seed()); } function upgraded() external view returns (bool) { return _upgrade != address(0); } function upgrade() external view returns (address) { return _upgrade; } function stake() external view returns (address) { return address(_stake); } function _createNewProposal(ProposalType pType) internal active returns (uint64) { // Make sure this isn't spam by transferring the proposal fee require(_SEED.transferFrom(msg.sender, address(this), PROPOSAL_FEE)); // Increment the next proposal ID now // Means we don't have to return a value we subtract one from later _nextProposalID += 1; emit NewProposal(_nextProposalID); // Set up the proposal's metadata ProposalMetadata storage meta = proposals[_nextProposalID]; meta.pType = pType; meta.creator = msg.sender; meta.submitted = block.timestamp; // Automatically vote for the proposal's creator meta.stakers[msg.sender] = true; emit ProposalVoteAdded(_nextProposalID, msg.sender); return _nextProposalID; } function proposeFund(address destination, uint256 amount, string calldata info) external returns (uint64) { uint64 proposalID = _createNewProposal(ProposalType.Fund); _fundProposals[proposalID] = FundProposal(destination, amount, info); emit FundProposed(proposalID, destination, amount); return proposalID; } function proposeMelodyAddition(address melody, string calldata info) external returns (uint64) { uint64 proposalID = _createNewProposal(ProposalType.MelodyAddition); _melodyAdditionProposals[proposalID] = MelodyAdditionProposal(melody, info); emit MelodyAdditionProposed(proposalID, melody); return proposalID; } function proposeMelodyRemoval(address melody, string calldata info) external returns (uint64) { uint64 proposalID = _createNewProposal(ProposalType.MelodyRemoval); _melodyRemovalProposals[proposalID] = MelodyRemovalProposal(melody, info); emit MelodyRemovalProposed(proposalID, melody); return proposalID; } function proposeStakeUpgrade(address newStake, address[] calldata owned, string calldata info) external returns (uint64) { uint64 proposalID = _createNewProposal(ProposalType.StakeUpgrade); // Ensure the SEED token was included as an owned contract for (uint i = 0; i < owned.length; i++) { if (owned[i] == address(_SEED)) { break; } require(i != owned.length - 1); } _stakeUpgradeProposals[proposalID] = StakeUpgradeProposal(newStake, owned, info); emit StakeUpgradeProposed(proposalID, newStake); return proposalID; } function proposeDAOUpgrade(address newDAO, string calldata info) external returns (uint64) { uint64 proposalID = _createNewProposal(ProposalType.DAOUpgrade); _daoUpgradeProposals[proposalID] = DAOUpgradeProposal(newDAO, info); emit DAOUpgradeProposed(proposalID, newDAO); return proposalID; } function addVote(uint64 proposalID) external active pendingProposal(proposalID) { proposals[proposalID].stakers[msg.sender] = true; emit ProposalVoteAdded(proposalID, msg.sender); } function removeVote(uint64 proposalID) external active pendingProposal(proposalID) { proposals[proposalID].stakers[msg.sender] = false; emit ProposalVoteRemoved(proposalID, msg.sender); } // Send the SEED held by this contract to what it upgraded to // Intended to enable a contract like the timelock, if transferred to this // Without this, it'd be trapped here, forever function forwardSEED() public { require(_upgrade != address(0)); require(_SEED.transfer(_upgrade, _SEED.balanceOf(address(this)))); } // Complete a proposal // Takes in a list of stakers so this contract doesn't have to track them all in an array // This would be extremely expensive as a stakers vote weight can drop to 0 // This selective process allows only counting meaningful votes function completeProposal(uint64 proposalID, address[] calldata stakers) external active pendingProposal(proposalID) noReentrancy { ProposalMetadata storage meta = proposals[proposalID]; uint256 requirement; // Only require a majority vote for a funding request/to remove a melody if ((meta.pType == ProposalType.Fund) || (meta.pType == ProposalType.MelodyRemoval)) { requirement = _stake.totalStaked().div(2).add(1); // Require >66% to add a new melody // Adding an insecure or malicious melody will cause the staking pool to be drained } else if (meta.pType == ProposalType.MelodyAddition) { requirement = _stake.totalStaked().div(3).mul(2).add(1); // Require >80% to upgrade the stake/DAO contract // Upgrading to an insecure or malicious contract risks unlimited minting } else if ((meta.pType == ProposalType.StakeUpgrade) || (meta.pType == ProposalType.DAOUpgrade)) { requirement = _stake.totalStaked().div(5).mul(4).add(1); // Panic in case the enum is expanded and not properly handled here } else { require(false); } // Make sure there's enough vote weight behind this proposal uint256 votes = 0; for (uint i = 0; i < stakers.length; i++) { // Don't allow people to vote with flash loans if (_stake.lastClaim(stakers[i]) == block.timestamp) { continue; } require(meta.stakers[stakers[i]]); require(!used[proposalID][stakers[i]]); used[proposalID][stakers[i]] = true; votes = votes.add(_stake.staked(stakers[i])); } require(votes >= requirement); meta.completed = true; emit ProposalPassed(proposalID); if (meta.pType == ProposalType.Fund) { FundProposal memory proposal = _fundProposals[proposalID]; require(_SEED.transfer(proposal.destination, proposal.amount)); } else if (meta.pType == ProposalType.MelodyAddition) { _stake.addMelody(_melodyAdditionProposals[proposalID].melody); } else if (meta.pType == ProposalType.MelodyRemoval) { _stake.removeMelody(_melodyRemovalProposals[proposalID].melody); } else if (meta.pType == ProposalType.StakeUpgrade) { StakeUpgradeProposal memory proposal = _stakeUpgradeProposals[proposalID]; for (uint i = 0; i < proposal.owned.length; i++) { _stake.upgrade(proposal.owned[i], proposal.newStake); } // Register the new staking contract as a melody so it can move the funds over _stake.addMelody(address(proposal.newStake)); _stake = ISeedStake(proposal.newStake); } else if (meta.pType == ProposalType.DAOUpgrade) { _upgrade = _daoUpgradeProposals[proposalID].newDAO; _stake.transferOwnership(_upgrade); forwardSEED(); } else { require(false); } } // Voluntarily withdraw a proposal function withdrawProposal(uint64 proposalID) external active pendingProposal(proposalID) { require(proposals[proposalID].creator == msg.sender); proposals[proposalID].completed = true; emit ProposalRemoved(proposalID); } }
gpt-4
Make a smart contract to transfer ownership and control of a contract. The purpose of the contract is to allow the current owner to transfer ownership to a new owner and to renounce ownership, leaving the contract without an owner.
pragma solidity 0.4.24; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } contract YOK is CappedToken { string public name = "YOKcoin"; string public symbol = "YOK"; uint8 public decimals = 18; constructor( uint256 _cap ) public CappedToken( _cap ) { } }
gpt-4
Make a smart contract to update the implementation address and trigger an event when the implementation is updated. The contract also allows for changing the admin address and disabling the change of admin.
pragma solidity 0.6.5; abstract contract Proxy { // /////////////////////// EVENTS /////////////////////////////////////////////////////////////////////////// event ProxyImplementationUpdated( address indexed previousImplementation, address indexed newImplementation ); // /////////////////////// CONSTRUCTOR ////////////////////////////////////////////////////////////////////// function _setImplementation(address newImplementation, bytes memory data) internal { address previousImplementation; // solhint-disable-next-line security/no-inline-assembly assembly { previousImplementation := sload( 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ) } // solhint-disable-next-line security/no-inline-assembly assembly { sstore( 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, newImplementation ) } emit ProxyImplementationUpdated( previousImplementation, newImplementation ); if (data.length > 0) { (bool success, ) = newImplementation.delegatecall(data); if (!success) { assembly { // This assembly ensure the revert contains the exact string data let returnDataSize := returndatasize() returndatacopy(0, 0, returnDataSize) revert(0, returnDataSize) } } } } // ///////////////////// EXTERNAL /////////////////////////////////////////////////////////////////////////// receive() external payable { _fallback(); } fallback() external payable { _fallback(); } // ///////////////////////// INTERNAL ////////////////////////////////////////////////////////////////////// function _fallback() internal { // solhint-disable-next-line security/no-inline-assembly assembly { let implementationAddress := sload( 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ) calldatacopy(0x0, 0x0, calldatasize()) let success := delegatecall( gas(), implementationAddress, 0x0, calldatasize(), 0, 0 ) let retSz := returndatasize() returndatacopy(0, 0, retSz) switch success case 0 { revert(0, retSz) } default { return(0, retSz) } } } } contract TransparentProxy is Proxy { // /////////////////////// CONSTRUCTOR ////////////////////////////////////////////////////////////////////// constructor( address implementationAddress, bytes memory data, address adminAddress ) public { _setImplementation(implementationAddress, data); _setAdmin(adminAddress); } // ///////////////////// EXTERNAL /////////////////////////////////////////////////////////////////////////// function changeImplementation( address newImplementation, bytes calldata data ) external ifAdmin { _setImplementation(newImplementation, data); } function proxyAdmin() external ifAdmin returns (address) { return _admin(); } // Transfer of adminship on the other hand is only visible to the admin of the Proxy function changeProxyAdmin(address newAdmin) external ifAdmin { uint256 disabled; // solhint-disable-next-line security/no-inline-assembly assembly { disabled := sload( 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6102 ) } require(disabled == 0, "changeAdmin has been disabled"); _setAdmin(newAdmin); } // to be used if EIP-173 needs to be implemented in the implementation contract so that change of admin can be constrained // in a way that OwnershipTransfered is trigger all the time function disableChangeProxyAdmin() external ifAdmin { // solhint-disable-next-line security/no-inline-assembly assembly { sstore( 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6102, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } } // /////////////////////// MODIFIERS //////////////////////////////////////////////////////////////////////// modifier ifAdmin() { if (msg.sender == _admin()) { _; } else { _fallback(); } } // ///////////////////////// INTERNAL ////////////////////////////////////////////////////////////////////// function _admin() internal view returns (address adminAddress) { // solhint-disable-next-line security/no-inline-assembly assembly { adminAddress := sload( 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103 ) } } function _setAdmin(address newAdmin) internal { // solhint-disable-next-line security/no-inline-assembly assembly { sstore( 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103, newAdmin ) } } }
gpt-4
Make a smart contract to manage a token called TokenERC20. The purpose of the contract is to allow users to transfer tokens between addresses, check their token balance, and approve other addresses to spend tokens on their behalf. The contract also keeps track of the total token supply.
pragma solidity 0.4.19; interface tokenRecipient 
